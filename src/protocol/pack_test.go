package protocol

import (
	"testing"
	"bytes"
	"strings"
	// "fmt"
)

var messages = map[string]string{
	"60 02 90 F7 2F 01":"A5 5A 60 02 90 F7 2F 01 18 08 CC 33 C3 3C",  //Registration
	// "0c 04 BC 61 4E 01 13 07 18 11 19 06 11 00 00 00 00 0b cf 03 cf 00 00 05 dc 10 00 00 00 65 09": "a5 5a 0c 04 BC614E 01 130718111906 11 0000 0000 0b cf 03 cf 00 00 05 dc 10 00 00 00 65 09 9f 21 cc 33 c3 3c", //RealtimeData
	"3D 02 90 F7 2F 02 11 13 01 08 0A 1C 21 13 01 08 0A 1D 21 17 D3 00 C7 01 2C 00 82 00 00 00 00 00 00 00 00 00 82 00 00 00 00 01 04" : "A5 5A 3D 02 90 F7 2F 02 11 13 01 08 0A 1C 21 13 01 08 0A 1D 21 17 D3 00 C7 01 2C 00 82 00 00 00 00 00 00 00 00 00 82 00 00 00 00 01 04 B5 2D CC 33 C3 3C", //CycleInfo
	"3d 01 90 fb f1 01 11 13 07 12 10 0b 15 13 07 12 10 10 2d 04 85 00 eb 00 c7 00 5b 00 fd 00 54 05 69 00 fc 00 a3 08 87 00 b3 00 5b" : "a5 5a 3d 01 90 fb f1 01 11 13 07 12 10 0b 15 13 07 12 10 10 2d 04 85 00 eb 00 c7 00 5b 00 fd 00 54 05 69 00 fc 00 a3 08 87 00 b3 00 5b 31 2d cc 33 c3 3c", //CycleInfo2
	"80 02 90 F7 2F 3C" : "A5 5A 80 02 90 F7 2F 3C 73 08 CC 33 C3 3C", //HeartBeat
	"8E 02 90 F7 2F 3C" : "A5 5A 8E 02 90 F7 2F 3C 81 08 CC 33 C3 3C", //HeartBeatResponse
	"310490fae20136000002300078003c03fc0bb81770003536313300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00" : "a55a310490fae20136000002300078003c03fc0bb81770003536313300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00df59cc33c33c",
	"330490fae206c8001e07b6012c08170014082903e800590000006403e806d8000008dc0e10030a000000000000004c000000000000":"a55a330490fae206c8001e07b6012c08170014082903e800590000006403e806d8000008dc0e10030a000000000000004c000000000000a837cc33c33c",
	"350490fae2003c003c006400640044018600780078005a005a002f012c":"a55a350490fae2003c003c006400640044018600780078005a005a002f012caf1fcc33c33c",
	"370490fae200320191000103e882d002d0":"a55a370490fae200320191000103e882d002d07a13cc33c33c",

	"2f0490fae20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"a55a2f0490fae200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb7cc33c33c",
	"800490fae23c" : "a55a800490fae23c2b08cc33c33c",
}

// a55a310490fae20136000002300078003c03fc0bb81770003536313300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00df59cc33c33c
// a55a330490fae206c8001e07b6012c08170014082903e800590000006403e806d8000008dc0e10030a000000000000004c000000000000a837cc33c33c
// a55a350490fae2003c003c006400640044018600780078005a005a002f012caf1fcc33c33c
// a55a370490fae200320191000103e882d002d07a13cc33c33c
// a55a2f0490fae200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009eb7cc33c33c
// a55a800490fae23c2b08cc33c33c
//
// a55a0c0490fae201130c1b0a2619110000000008870000000005dc000000006519fe21cc33c33c
// a55a0c0490fae201130c1b0a2628110000000008870000000005dc0000000065190d21cc33c33c
// a55a0c0490fae201130c1b0a2636110000000008870000000005dc0000000065191b21cc33c33c
// a55a0c0490fae201130c1b0a2709110000000008870000000005dc000000006519ef21cc33c33c
// a55a310490fae20136000002300078003c03fc0bb81770003536313300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00df59cc33c33ca55a330490fae206c8001e07b6012c08170014082903e800590000006403e806d8000008dc0e10030a000000000000004c000000000000a837cc33c33ca55a350490fae2003c003c006400640044018600780078005a005a002f012caf1fcc33c33ca55a370490fae200320191000103e882d002d07a13cc33c33c

// 55a0c0490fae201130c1b0a2812110000000008870000000005dc000000006519f921cc33c33c
// a55a0c0490fae201130c1b0a2821110000000008870000000005dc0000000065190821cc33c33c

// a55a0c0490fae201130c1b0a1b16110000000008870000000005dc000000006519f021cc33c33c
// a55a0c0490fae201130c1b0a1b25110000000008870000000005dc000000006519ff21cc33c33c
// a55a0c0490fae201130c1b0a1b34110000000008870000000005dc0000000065190e21cc33c33c
// a55a0c0490fae201130c1b0a1c07110000000008870000000005dc000000006519e221cc33c33c

type TestCase struct {
	message []byte
	frame []byte
}

func MergeSlice(s1 []byte, s2 []byte) []byte {
    slice := make([]byte, len(s1)+len(s2))
    copy(slice, s1)
    copy(slice[len(s1):], s2)
    return slice
}

func convert2TestCases(msgMap map[string]string) []TestCase {

	var testcases = make([]TestCase, 0, len(msgMap))

	for msg, frame := range msgMap {

		dst := HextoB(strings.ReplaceAll(msg, " ", ""))
		// fmt.Printf("%s\n", BytetoH(dst))
		// fmt.Printf("%s\n",strings.ReplaceAll(msg, " ", ""))
		dst2 := HextoB(strings.ReplaceAll(frame, " ", ""))
		// fmt.Printf("%s\n", BytetoH(dst2))
		// fmt.Printf("%s\n",strings.ReplaceAll(frame, " ", ""))
		testcases = append(testcases, TestCase{dst, dst2})
	}
	return testcases
}


func TestCountChecksum(t *testing.T){
	var testcases = convert2TestCases(messages)
    for _, tc := range testcases {
		result := countChecksum(tc.frame[:len(tc.frame)-6])
        if  result != tc.frame[len(tc.frame)-6] {
			t.Errorf("countChecksum failed: %s -- %x -- %x", BytetoH(tc.frame), tc.frame[len(tc.frame)-6] ,result )
        }
	}
	
}

func TestPack(t *testing.T) {
	var testcases = convert2TestCases(messages)
    for _, tc := range testcases {
		result := Pack(tc.message)
        if ! bytes.Equal(result, tc.frame) {
			t.Errorf("pack failed: %s -- %s" , BytetoH(result) ,BytetoH(tc.frame)   )
        }
	}
}

func TestUnpack(t *testing.T) {
	var testcases = convert2TestCases(messages)
    for _, tc := range testcases {
		_, results := Unpack(tc.frame)
		for _, msg := range results {
			if ! bytes.Equal(msg, tc.message) {
				t.Errorf("unpack failed, result: %s", BytetoH(msg) )
			}
		}
	}
	if len(testcases) > 1 {
		merged := MergeSlice(testcases[len(testcases)-2].frame, testcases[len(testcases)-1].frame)
		
		_, results := Unpack(merged)
		if len(results) != 2 {
			t.Errorf("unpack merged frame failed, result: %s", BytetoH(merged) )
		}
	}



	// messages
}


